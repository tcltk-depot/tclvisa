\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

\makeindex

\newcommand{\tclvisa}{{\tt tclvisa }}
\newcommand{\indexentry}[2]{\item #1 #2}
\newcommand{\VISA}{\mbox{VISA }}

\newcommand{\COMMANDREF}[1]{{\tt \hyperref[#1]{#1}}}
\newcommand{\VISACOMMANDREF}[1]{{\tt \mbox{#1}}\index{#1}}
\newcommand{\TCLCOMMANDREF}[1]{{\tt \mbox{#1}}\index{#1}}

\newcommand{\SEEALSO}{\subsection*{See Also}}
\newcommand{\EXAMPLE}{\subsection*{Example}}
\newcommand{\PURPOSE}{\subsection*{Purpose}}
\newcommand{\SYNTAX}[1]{\subsection*{Syntax}{\tt #1}}
\newcommand{\NOTES}{\subsection*{Notes}}
\newcommand{\ARGUMENTS}{\subsubsection*{Arguments}}
\newcommand{\RETURN}{\subsubsection*{Return Value}}
\newcommand{\NORETURN}{\subsubsection*{Return Value} None}
\newcommand{\COMMAND}[1]{\section{#1}\label{#1}}
\newcommand{\BEGINARGUMENTS}{\ARGUMENTS\begin{itemize}}
\newcommand{\ENDARGUMENTS}{\end{itemize}}
\newcommand{\NOARGUMENTS}{\ARGUMENTS None}
\newcommand{\ARGUMENT}[1]{\item {\tt \mbox{#1}}~---}

\newcommand{\ARGCHANNEL}{\ARGUMENT{session} channel containing reference to a \VISA resource session opened by \COMMANDREF{visa::open}.}
\newcommand{\ARGRM}{\ARGUMENT{RMsession} channel containing reference to open Resource Manager session opened by \COMMANDREF{visa::open-default-rm}.}

\input title.tex

\begin{document}

\maketitle

\tableofcontents

\chapter{Getting Started}

\section{Introduction}

\tclvisa is a standard Tcl extension providing a binding to Virtual Instrument Software Architecture (\VISA) API. It allows to use \VISA functionality from regular Tcl scripts via set of commands. Most of the commands have similar names and are intuitive to use for the one who knows \VISA API. For example, Tcl command \COMMANDREF{visa::open} is a front-end for \VISACOMMANDREF{viOpen} \VISA function. The specifications of \VISA can be found here: 

\href{http://www.ivifoundation.org/specifications/default.aspx}{http://www.ivifoundation.org/specifications/default.aspx}.

As an extention \tclvisa follows conventions of Tcl Extension Architecture (TEA). It is loaded dynamically into Tcl shell or Tcl-based application on demand. Please refer to TEA documentations for details: 

\href{http://www.tcl.tk/doc/tea/}{http://www.tcl.tk/doc/tea/}.

\section{Installation}

Prior to usage of \tclvisa one need \VISA implementation installed. There are several known implementations (e.g. National Instruments VISA, or Agilent IO Library Suite). \VISA libraries should be installed in proper directories and be available for linking.

\tclvisa itself should be installed as a typical Tcl extension. Partcular details of installation, such as target directory, are platform-dependent. Please refer to the documentation of your Tcl version.

If you have no access to system directories to install \tclvisa into, you can install into arbitrary directory. In order to make Tcl known about this directory, you should add path to it to \mbox{\tt TCLLIBPATH} environment variable.

\section{Use in Tcl}

In order to start using \tclvisa within Tcl one should issue following command:

\begin{verbatim} 
package require tclvisa
\end{verbatim} 

If the library is properly installed, this command returns version of \tclvisa loaded. Library is ready to use. All commands and predefined variables are placed in {\tt visa::} namespace.

\chapter{Programming with \tclvisa}

\section{Channels}

Most of \VISA functions operate with \emph{sessions} which are represented in C~language by {\tt viSession} type. In Tcl these sessions are stored in standard channels. E.~g. \COMMANDREF{visa::open} returns name of Tcl channel to be used in subsequent operations. This approach has following benefits:

\begin{itemize}
\item Standard IO procedures are used in \VISA IO: \TCLCOMMANDREF{puts}, \TCLCOMMANDREF{gets} etc.
\item \VISA sessions may be transparently passed to any procedure which accepts Tcl channel. If some third-party library works with regular Tcl channels, it therefore can read/write from/to \VISA device.
\item Tcl automatically closes all opened channels when interpeter terminates.
\end{itemize}

\tclvisa provides a procedure to open \VISA sessions: \COMMANDREF{visa::open}, which is a front-end of \VISACOMMANDREF{viOpen} \VISA function. But \tclvisa does not provide front-ends for \VISACOMMANDREF{viClose} or \VISACOMMANDREF{viWrite} \VISA functions. Instead one should use standard Tcl commands, such as \TCLCOMMANDREF{close} or \TCLCOMMANDREF{puts}. Tcl detects type of the channel and calls proper \VISA function internally. For example, when \TCLCOMMANDREF{close} is issued on \VISA channel, opened by \COMMANDREF{visa::open}, then \VISACOMMANDREF{viClose} function is actually called within Tcl internals.

Following example demonstrates usage of \VISA channel:

\begin{verbatim} 
# open instrument
set vi [visa::open $rm "ASRL2::INSTR"]

# send "reset" command to instrument
puts $vi "*RST"

# close VISA session
close $vi
\end{verbatim} 

See also \hyperref[sec_correspondence]{table of correspondence} between supported \VISA functions and Tcl commands.

\subsection{Buffering}

\VISA IO functions, such as \VISACOMMANDREF{viWrite} or \VISACOMMANDREF{viRead}, by default work with \emph{messages}, where message is a sequence of bytes of arbitrary length followed by special ``end-of-message'' character. For example, \href{http://www.ivifoundation.org/scpi/default.aspx}{SCPI} messages end with ``new line'' character (ASCII code is {\tt 0Ah}). When I send a message terminated by ``end-of-message'' via \VISACOMMANDREF{viWrite}, I can be sure that it is actually sent to the device rather than kept in intermediate buffer. When I call \VISACOMMANDREF{viRead}, it returns immediately after receiving of ``end-of-message'' character regardless of the length of input buffer.

Tcl channels by default work with continuous streams of bytes. IO functions typically block until IO buffer is full or ``end-of-data'' is detected. For example, \TCLCOMMANDREF{read} command called without a buffer length specified on file channel blocks until entire file is read. It's evident that this approach does not work with message-based protocols like SCPI.

Fortunately Tcl offers different buffering options, which can be set or red by \TCLCOMMANDREF{fconfigure} command. One of them is ``{\tt -buffering line}'' which tells Tcl finish current IO operation when ``end-of-line'' character is received or sent. When buffering type is ``{\tt line}'', \TCLCOMMANDREF{read} blocks until ``end-of-line'' is received, and \TCLCOMMANDREF{puts} actually sends data right after ``end-of-line'' is found in outcoming data. In the terms or SCPI commands, \TCLCOMMANDREF{read} blocks until complete response is received from a device.

When \VISA channel is created by \COMMANDREF{visa::open}, buffering type is automatically set to ``{\tt line}''. If one needs to switch channel mode, then \TCLCOMMANDREF{fconfigure} command with proper {\tt -buffering} option should be issued.

\section{\VISA Constants}

\VISA defines a lot of predefined contants with codes of attributes, errors etc. Most of these constants are available in Tcl within {\tt visa} namespace and without {\tt VI\_} prefix.

For example, {\tt VI\_EXCLUSIVE\_LOCK} constant is represented by \\{\tt visa::EXCLUSIVE\_LOCK} variable in Tcl. When using these predefined variables in expressions, do not forget adding {\tt \$} prefix prior to variable name.

Following example demonstrates usage of predefined constant:

\begin{verbatim} 
# open instrument exclusively
set vi [visa::open $rm "ASRL2::INSTR" $visa::EXCLUSIVE_LOCK]
\end{verbatim} 

\section{Correspondence Between \VISA Functions and Tcl Commands}
\label{sec_correspondence}

Following table contains list of \VISA API functions supported by \tclvisa and corresponding commands to use in Tcl.

\begin{tabular}{ll}
\VISA API function & Tcl Command \\
\VISACOMMANDREF{viClear} & \COMMANDREF{visa::clear}	\\
\VISACOMMANDREF{viClose} & \TCLCOMMANDREF{close}	\\
\VISACOMMANDREF{viFindNext}, \VISACOMMANDREF{viFindRsrc} & \COMMANDREF{visa::find}	\\
\VISACOMMANDREF{viGetAttribute} & \COMMANDREF{visa::get-attribute}	\\
\VISACOMMANDREF{viLock} & \COMMANDREF{visa::lock}	\\
\VISACOMMANDREF{viOpen} & \COMMANDREF{visa::open}	\\
\VISACOMMANDREF{viOpenDefaultRM} & \COMMANDREF{visa::open-default-rm}	\\
\VISACOMMANDREF{viParseRsrc} & \COMMANDREF{visa::parse-rsrc}	\\
\VISACOMMANDREF{viPrintf} & \TCLCOMMANDREF{format}, \TCLCOMMANDREF{puts}	\\
\VISACOMMANDREF{viQueryf} & \TCLCOMMANDREF{format}, \TCLCOMMANDREF{puts}, \TCLCOMMANDREF{gets}, \TCLCOMMANDREF{scan}	\\
\VISACOMMANDREF{viRead} & \TCLCOMMANDREF{read}	\\
\VISACOMMANDREF{viReadToFile} & \COMMANDREF{visa::read-to-file}	\\
\VISACOMMANDREF{viScanf} & \TCLCOMMANDREF{gets}, \TCLCOMMANDREF{scan}	\\
\VISACOMMANDREF{viSetAttribute} & \COMMANDREF{visa::set-attribute}	\\
\VISACOMMANDREF{viUnlock} & \COMMANDREF{visa::unlock}	\\
\VISACOMMANDREF{viWrite} & \TCLCOMMANDREF{puts}	\\
\VISACOMMANDREF{viWriteFromFile} & \COMMANDREF{visa::write-from-file}	\\
\end{tabular}

\chapter{\tclvisa Command Reference}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\COMMAND{visa::clear}

\PURPOSE

Clears a device. This command is a front-end for \VISACOMMANDREF{viClear} \VISA API function.

\SYNTAX{visa::clear session}

\BEGINARGUMENTS
\ARGCHANNEL
\ENDARGUMENTS

\NORETURN

\EXAMPLE

\begin{verbatim} 
# open instrument with default access mode and timeout
set vi [visa::open $rm "ASRL1::INSTR"]

# set device to known state
visa::clear $vi
\end{verbatim} 

\SEEALSO

\COMMANDREF{visa::open}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\COMMAND{visa::find}

\PURPOSE

Queries a VISA system to locate the resources associated with a specified interface. This command is a front-end for \VISACOMMANDREF{viFindRsrc} and \VISACOMMANDREF{viFindNext} \VISA API functions.

\SYNTAX{visa::open RMsession expr}

\BEGINARGUMENTS
\ARGRM
\ARGUMENT{expr} regular expression followed by an optional logical expression. Refer to \VISA API documentation for detailed discussion.
\ENDARGUMENTS

\RETURN

Tcl list with addresses of all resources found. If no resources found that match the given expression, empty list is returned.

\EXAMPLE

\begin{verbatim} 
# open resource manager session
set rm [visa::open-default-rm]

# get addresses of all serial instruments
foreach addr [visa::find $rm "ASRL?*INSTR"] {
  # address is in $addr variable
}
\end{verbatim} 

\SEEALSO

\COMMANDREF{visa::open-default-rm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\COMMAND{visa::get-attribute}

\PURPOSE

Retrieves the state of an attribute. This command is a front-end for \VISACOMMANDREF{viGetAttribute} \VISA API function.

\SYNTAX{visa::get-attribute session attribute}

\BEGINARGUMENTS
\ARGCHANNEL
\ARGUMENT{attribute} Integer value with ID of the \VISA attribute to retrieve. Use one of the predefned {\tt visa::ATTR\_XXX} constants.
\ENDARGUMENTS

\RETURN

Attribute value.

\EXAMPLE

\begin{verbatim} 
# open instrument with default access mode and timeout
set vi [visa::open $rm "ASRL1::INSTR"]

# retrieve current baud rate of a serial bus
set baud [visa::get-attribute $vi $visa::ATTR_ASRL_BAUD]
\end{verbatim} 

\SEEALSO

\COMMANDREF{visa::set-attribute}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\COMMAND{visa::lock}

\PURPOSE

Establishes an access mode to the specified resource. This command is a front-end for \VISACOMMANDREF{viLock} \VISA API function.

\SYNTAX{visa::lock session ?lockType? ?timeout? ?requestedKey?}

\BEGINARGUMENTS
\ARGCHANNEL
\ARGUMENT{lockType} integer value determining type of locking. May be either {\tt visa::EXCLUSIVE\_LOCK} or {\tt visa::SHARED\_LOCK}. If argument is omitted, {\tt visa::EXCLUSIVE\_LOCK} is assumed.
\ARGUMENT{timeout} timeout of getting lock. If argument is omitted, infinite timeout is assumed.
\ARGUMENT{requestedKey} name of the shared lock to acquire. If exclusive locking is requested, this argument is ignored.
\ENDARGUMENTS

\RETURN

\begin{itemize}
\item If an exclusive lock is requiested and acquired, procedure returns nothing.
\item If an shared lock is requiested and acquired, procedure returns name of the lock.
\end{itemize}

\EXAMPLE

\begin{verbatim} 
# get exclusive lock and wait forever
visa::lock $vi

# get exclusive lock and wait 5 seconds
visa::lock $vi $visa::EXCLUSIVE_LOCK 5000

# get shared lock and wait 5 seconds
set key [visa::lock $vi $visa::SHARED_LOCK 5000 "MYLOCK"]
\end{verbatim} 

\SEEALSO

\COMMANDREF{visa::open}, \COMMANDREF{visa::unlock}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\COMMAND{visa::open}

\PURPOSE

Opens a session to the specified resource. This command is a front-end for \VISACOMMANDREF{viOpen} \VISA API function.

\SYNTAX{visa::open RMsession rsrcName ?accessMode? ?openTimeout?}

\BEGINARGUMENTS
\ARGRM
\ARGUMENT{rsrcName} name of the VISA resource to connect to.
\ARGUMENT{accessMode} integer parameter determining access mode. May be bitwise OR combination of the following constants:
	\begin{itemize}
	\item {\tt visa::EXCLUSIVE\_LOCK}~--- acquire exclusive lock to a resource;
	\item {\tt visa::LOAD\_CONFIG}~--- use external configuration;
	\end{itemize}
	Refer to \VISA documentation for more details about access mode. If parameter is omitted, default zero value is used.
\ARGUMENT{openTimeout} operation timeout. If parameter is omitted, default timeout value is used.
\ENDARGUMENTS

\RETURN

Tcl channel with reference to opened VISA session. This channel can be used in standard Tcl IO procedures, like \TCLCOMMANDREF{puts}.

\NOTES

There is no a Tcl wrapper for \VISACOMMANDREF{viClose} \VISA API function. In order to close a \VISA session one should use standard Tcl \TCLCOMMANDREF{close} command instead, which calls \VISACOMMANDREF{viClose} internally.

\EXAMPLE

\begin{verbatim} 
# open resource manager session
set rm [visa::open-default-rm]

# open instrument with default access mode and timeout
set vi1 [visa::open $rm "ASRL1::INSTR"]

# open instrument exclusively
set vi2 [visa::open $rm "ASRL2::INSTR" $visa::EXCLUSIVE_LOCK]
\end{verbatim} 

\SEEALSO

\COMMANDREF{visa::open-default-rm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\COMMAND{visa::open-default-rm}

\PURPOSE

Returns a session to the Default Resource Manager resource. This command is a front-end for \VISACOMMANDREF{viOpenDefaultRM} \VISA API function.

\SYNTAX{visa::open-default-rm}

\NOARGUMENTS

\RETURN

Tcl channel with reference to opened resource manager session. This channel can be used in subsequent \tclvisa procedure calls.

\NOTES

There is no a Tcl wrapper for \VISACOMMANDREF{viClose} \VISA API function. In order to close a \VISA session one should use standard Tcl \TCLCOMMANDREF{close} command instead, which calls \VISACOMMANDREF{viClose} internally.

\EXAMPLE

\begin{verbatim} 
# open resource manager session
set rm [visa::open-default-rm]

# use session reference
...

# close session
close $rm
\end{verbatim} 

\SEEALSO

\COMMANDREF{visa::open}

\COMMAND{visa::set-attribute}

\PURPOSE

Sets the state of an attribute. This command is a front-end for \VISACOMMANDREF{viSetAttribute} \VISA API function.

\SYNTAX{visa::set-attribute session attribute attrState}

\BEGINARGUMENTS
\ARGCHANNEL
\ARGUMENT{attribute} Integer value with ID of the \VISA attribute to set. Use one of the predefned {\tt visa::ATTR\_XXX} constants.
\ARGUMENT{attrState} Integer value with desired attribute state.
\ENDARGUMENTS

\NORETURN

\EXAMPLE

\begin{verbatim} 
# open instrument with default access mode and timeout
set vi [visa::open $rm "ASRL1::INSTR"]

# set new baud rate of a serial bus
visa::set-attribute $vi $visa::ATTR_ASRL_BAUD 19200
\end{verbatim} 

\SEEALSO

\COMMANDREF{visa::get-attribute}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\COMMAND{visa::parse-rsrc}

\PURPOSE

Parse a resource string to get the interface information. This command is a front-end for \VISACOMMANDREF{viParseRsrc} \VISA API function.

\SYNTAX{visa::parse-rsrc RMsession rsrcName}

\BEGINARGUMENTS
\ARGRM
\ARGUMENT{rsrcName} Unique symbolic name of a resource.
\ENDARGUMENTS

\RETURN

\begin{itemize}
\item On success returns Tcl list of two integers: interface type code and interface number.
\item If address given is not valid or device does not exists, returns empty value.
\end{itemize}

\EXAMPLE

\begin{verbatim} 
# open resource manager session
set rm [visa::open-default-rm]

# parse instrument address
lassign [visa::parse-rsrc $rm "ASRL1::INSTR"] intfType intfNum

if { $intfType == $visa::INTF_ASRL } {
  puts "Have serial interface device with interface number $intfNum"
}
\end{verbatim} 

\SEEALSO

\COMMANDREF{visa::open-default-rm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\COMMAND{visa::read-to-file}

\PURPOSE

Read data synchronously, and store the transferred data in a file. This command is a front-end for \VISACOMMANDREF{viReadToFile} \VISA API function.

\SYNTAX{visa::read-to-file session fileName count}

\BEGINARGUMENTS
\ARGCHANNEL
\ARGUMENT{fileName} name of file to which data will be written.
\ARGUMENT{count} number of bytes to be read.
\ENDARGUMENTS

\RETURN

Number of bytes actually transferred.

\EXAMPLE

\begin{verbatim} 
# open instrument with default access mode and timeout
set vi [visa::open $rm "ASRL1::INSTR"]

# read up to 1024 bytes of data 
# or until term char is received
visa::read-to-file $vi "raw.dat" 1024
\end{verbatim} 

\SEEALSO

\COMMANDREF{visa::write-from-file}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\COMMAND{visa::unlock}

\PURPOSE

Relinquishes a lock for the specified resource. This command is a front-end for \VISACOMMANDREF{viUnlock} \VISA API function.

\SYNTAX{visa::unlock session}

\BEGINARGUMENTS
\ARGCHANNEL
\ENDARGUMENTS

\NORETURN

\EXAMPLE

\begin{verbatim} 
# get exclusive lock and wait forever
visa::lock $vi

# release the lock
visa::unlock $vi
\end{verbatim} 

\SEEALSO

\COMMANDREF{visa::open}, \COMMANDREF{visa::lock}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\COMMAND{visa::write-from-file}

\PURPOSE

Take data from a file and write it out synchronously.
This command is a front-end for \VISACOMMANDREF{viWriteFromFile} \VISA API function.

\SYNTAX{visa::write-from-file session fileName ?count?}

\BEGINARGUMENTS
\ARGCHANNEL
\ARGUMENT{fileName} name of file from which data will be read.
\ARGUMENT{count} number of bytes to be written. If omitted, entire file is written.
\ENDARGUMENTS

\RETURN

Number of bytes actually transferred.

\EXAMPLE

\begin{verbatim} 
# open instrument with default access mode and timeout
set vi [visa::open $rm "ASRL1::INSTR"]

# write entire file content to device
visa::write-from-file $vi "raw.dat"
\end{verbatim} 

\SEEALSO

\COMMANDREF{visa::read-to-file}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\begin{theindex}
%\input tclvisa.idx
%\end{theindex}

\end{document}
